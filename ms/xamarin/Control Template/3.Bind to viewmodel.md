# Bind control template to viewmodel

A `ControlTemplate` can data bind to a **viewmodel**, even when the `ControlTemplate` binds to the **templated parent** (the runtime object instance to which the template is applied).

The following XAML example shows a page that consumes a viewmodel named `PeopleViewModel`:

```xml
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:local="clr-namespace:ControlTemplateDemos"
             xmlns:controls="clr-namespace:ControlTemplateDemos.Controls"
             ...>
    <ContentPage.BindingContext>
        <local:PeopleViewModel />
    </ContentPage.BindingContext>

    <ContentPage.Resources>
        <DataTemplate x:Key="PersonTemplate">
            <controls:CardView BorderColor="DarkGray"
                               CardTitle="{Binding Name}"
                               CardDescription="{Binding Description}"
                               ControlTemplate="{StaticResource CardViewControlTemplate}" />
        </DataTemplate>
    </ContentPage.Resources>

    <StackLayout Margin="10"
                 BindableLayout.ItemsSource="{Binding People}"
                 BindableLayout.ItemTemplate="{StaticResource PersonTemplate}" />
</ContentPage>
```
In this example, the `BindingContext` of the page is set to a `PeopleViewModel` instance. This viewmodel exposes a People collection and an ICommand named `DeletePersonCommand`. The StackLayout on the page uses a bindable layout to data bind to the People collection, and the `ItemTemplate` of the bindable layout is set to the `PersonTemplate` resource. This `DataTemplate` specifies that each item in the People collection will be displayed using a CardView object. The visual structure of the CardView object is defined using a `ControlTemplate` named `CardViewControlTemplate`:

```xml
<ControlTemplate x:Key="CardViewControlTemplate">
    <Frame BindingContext="{Binding Source={RelativeSource TemplatedParent}}"
           BackgroundColor="{Binding CardColor}"
           BorderColor="{Binding BorderColor}"
           CornerRadius="5"
           HasShadow="True"
           Padding="8"
           HorizontalOptions="Center"
           VerticalOptions="Center">
        <Grid>
            <Grid.RowDefinitions>
                <RowDefinition Height="75" />
                <RowDefinition Height="4" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Label Text="{Binding CardTitle}"
                   FontAttributes="Bold"
                   FontSize="Large"
                   VerticalTextAlignment="Center"
                   HorizontalTextAlignment="Start" />
            <BoxView Grid.Row="1"
                     BackgroundColor="{Binding BorderColor}"
                     HeightRequest="2"
                     HorizontalOptions="Fill" />
            <Label Grid.Row="2"
                   Text="{Binding CardDescription}"
                   VerticalTextAlignment="Start"
                   VerticalOptions="Fill"
                   HorizontalOptions="Fill" />
            <Button Text="Delete"
                    Command="{Binding Source={RelativeSource AncestorType={x:Type local:PeopleViewModel}}, Path=DeletePersonCommand}"
                    CommandParameter="{Binding CardTitle}"
                    HorizontalOptions="End" />
        </Grid>
    </Frame>
</ControlTemplate>
```

In this example, the root element of the `ControlTemplate` is a Frame object. The Frame object uses the *RelativeSource markup extension* to set its `BindingContext` to the templated parent. The binding expressions of the Frame object and its children resolve against CardView properties, due to inheriting the `BindingContext` from the root Frame element. 

While the objects in the ControlTemplate bind to properties on its templated parent, the Button within the control template binds to both its `templated parent`, and to the `DeletePersonCommand` in the viewmodel. This is because the Button.Command property redefines its binding source to be the binding context of the ancestor whose binding context type is `PeopleViewModel`, which is the StackLayout. The Path part of the binding expressions can then resolve the `DeletePersonCommand` property. However, the `Button.CommandParameter` property doesn't alter its binding source, instead inheriting it from its parent in the `ControlTemplate`. Therefore, the `CommandParameter` property binds to the CardTitle property of the CardView.

The overall effect of the Button bindings is that when the Button is tapped, the `DeletePersonCommand` in the PeopleViewModel class is executed, with the value of the CardName property being passed to the `DeletePersonCommand`. This results in the specified CardView being removed from the bindable layout