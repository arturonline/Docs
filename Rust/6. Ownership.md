# The Borrow checker

The borrow checker is the component in the Rust compiler that enforces this data ownership rules:

1. Each value in Rust has a variable that is called its owner.
1. There can only be one owner at a time.
1. When the owner goes out of scope, the value will be dropped.

## Variable Scope

A variable is valid from the point at which it’s declared until the end of the current scope.

```rust
fn main() {
{
// s is not valid here, it’s not yet declared
    let s = "hello";   // s is valid from this point forward
}
// this scope is now over, and s is no longer valid
}
```

## Move

All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.

### Stack values

Integers are simple values with a known, fixed size. In the example the two 5 values are pushed onto the stack:

```rust
let x = 5; // x = 5
let y = x; // y = 5
```

In this example rust binds the value of 5 to `x`; then makes a copy of the value in `x` and binds it to `y`.

### Heap values

Complex data types are allocated on the heap, like the `String` type.

```rust
let s1 = String::from("hello");
let s2 = s1; // s1 was moved into s2
```

This looks very similar to the previous code, so we might assume that the way it works would be the same: that is, the second line would make a copy of the value in `s1` and bind it to `s2`. But this isn’t true.

When we assign `s1` to `s2`, the String data is copied, meaning we copy the *pointer*, the *length*, and the *capacity* that are on the stack. We do not copy the data on the heap that the pointer refers to. Instead Rust considers `s1` to no longer be valid. Rust invalidation of the first variable it’s known as a **move**. In this example, we would say that `s1` was moved into `s2`.

![after](resources/ownership2.svg)

## Clone

If we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called clone.

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

## Functions

The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by drop unless the data has been moved to be owned by another variable. Passing a variable to a function will move or copy, just as assignment does.

```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```

If we tried to use s after the call to `takes_ownership`, Rust would throw a compile-time error. These static checks protect us from mistakes.

## Return values and Scope

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```
